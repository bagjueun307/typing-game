<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>í™œë™í˜• ì¹´íƒ„ ì˜í†  ëŒ€ì „</title>
    <style>
        :root { --p1: #3498db; --p2: #e74c3c; --fixed: #f1c40f; }
        body { background: #111; color: white; font-family: 'Malgun Gothic', sans-serif; margin: 0; overflow: hidden; }
        
        /* 4ê°œ ëª¨ë‹ˆí„° ë ˆì´ì•„ì›ƒ */
        .screen-container { display: grid; grid-template-columns: repeat(4, 25vw); height: 100vh; }
        .monitor { border: 4px solid #333; display: flex; flex-direction: column; align-items: center; padding: 20px; box-sizing: border-box; position: relative; }
        
        /* 4x4 í†µí•© ì§€ë„ (ë³¸ë¶€ì— í‘œì‹œ) */
        .main-map { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; width: 90%; }
        .cell { height: 70px; background: #333; border: 1px solid #555; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.8rem; border-radius: 5px; position: relative; }
        
        /* íŒ€ ì ë ¹ í‘œì‹œ */
        .p1-temp { background: rgba(52, 152, 219, 0.4); }
        .p2-temp { background: rgba(231, 76, 60, 0.4); }
        .p1-fixed { background: var(--p1) !important; border: 2px solid white; box-shadow: 0 0 15px var(--p1); }
        .p2-fixed { background: var(--p2) !important; border: 2px solid white; box-shadow: 0 0 15px var(--p2); }

        /* ì…ë ¥ì°½ ìœ„ì¹˜ ê°•ì¡° */
        .input-active { background: #222 !important; border: 5px solid var(--fixed) !important; }
        input { width: 90%; padding: 15px; font-size: 1.5rem; border-radius: 10px; border: none; text-align: center; margin-bottom: 20px; }
        
        .timer-bar { width: 100%; height: 10px; background: #444; position: absolute; top: 0; left: 0; }
        #swap-timer { height: 100%; width: 100%; background: var(--fixed); transition: width 0.1s linear; }

        .stat { font-size: 0.9rem; margin-bottom: 5px; }
        .level-tag { font-size: 0.7rem; background: rgba(0,0,0,0.5); padding: 2px 5px; border-radius: 3px; }
    </style>
</head>
<body>

<div class="screen-container">
    <div class="monitor" id="m1">
        <h2 id="m1-title">ğŸ¢ ë³¸ë¶€ (MAP)</h2>
        <div id="m1-input-area"></div>
        <div class="main-map" id="map-display"></div>
        <div style="display: flex; gap: 20px; margin-top: 20px;">
            <div class="p1-stat">P1 ìì›: <span id="p1-res">0/0/0/0</span></div>
            <div class="p2-stat">P2 ìì›: <span id="p2-res">0/0/0/0</span></div>
        </div>
        <div id="round-info" style="margin-top:10px; color: #f1c40f; font-weight:bold;">ë¼ìš´ë“œ 1/16 (ë‚¨ì€ ì‹œê°„: 60s)</div>
    </div>

    <div class="monitor" id="m2">
        <h2 id="m2-title">ğŸŒ² ìˆ²/ì‚° êµ¬ì—­</h2>
        <div id="m2-input-area"></div>
        <div id="m2-words"></div>
    </div>

    <div class="monitor" id="m3">
        <h2 id="m3-title">ğŸŒ¾ í‰ì•¼/ê´‘ì‚° êµ¬ì—­</h2>
        <div id="m3-input-area"></div>
        <div id="m3-words"></div>
    </div>

    <div class="monitor" id="m4">
        <h2 id="m4-title">ğŸ° ìš”ìƒˆ/í–‰ì • êµ¬ì—­</h2>
        <div id="m4-input-area"></div>
        <div id="m4-words"></div>
    </div>
</div>

<div class="timer-bar"><div id="swap-timer"></div></div>

<script>
    // 1. ê²Œì„ ìƒìˆ˜ ë° ì´ˆê¸° ë°ì´í„°
    const RES_TYPES = ['ğŸŒ²', 'ğŸ§±', 'ğŸŒ¾', 'â›ï¸'];
    const LEVELS = ['ë¹ˆí„°', 'ë§ˆì„', 'ë„ì‹œ', 'ê°œë°œêµ­', 'ì„ ì§„êµ­'];
    const WORD_BANK = ["ê°•ì‚°", "í•˜ëŠ˜", "ë°”ë‹¤", "ë‚˜ë¬´", "ê³¡ì‹", "ì² ê°•", "ë²½ëŒ", "íƒœì–‘", "ë‹¬ë¹›", "ë°”ëŒ", "ì•ˆê°œ", "í’€ì", "ì¤„ê¸°", "ë¿Œë¦¬", "ëª¨ë˜", "ìê°ˆ"];
    
    let gameState = {
        round: 1,
        roundTime: 60,
        swapTime: 10,
        map: Array.from({length: 16}, (_, i) => ({
            id: i,
            word: WORD_BANK[i],
            owner: null,      // ë¼ìš´ë“œ ë‚´ ì„ì‹œ ì ìœ 
            fixedOwner: null, // ì˜êµ¬ ì†Œìœ 
            level: 0,         // 0~4
            resType: i % 4    // ìì› ì¢…ë¥˜
        })),
        p1: { res: [0, 0, 0, 0], fixedCount: 0 },
        p2: { res: [0, 0, 0, 0], fixedCount: 0 },
        activeInputs: [0, 0] // [P1ì´ ìˆëŠ” ëª¨ë‹ˆí„°ID, P2ê°€ ìˆëŠ” ëª¨ë‹ˆí„°ID]
    };

    // 2. ì´ˆê¸°í™” ë° ìœ„ì¹˜ ëœë¤ ë³€ê²½
    function init() {
        renderMap();
        shuffleInputPositions();
        setInterval(tick, 1000);
    }

    function shuffleInputPositions() {
        const monitors = [1, 2, 3, 4];
        const shuffled = monitors.sort(() => Math.random() - 0.5);
        gameState.activeInputs = [shuffled[0], shuffled[1]];
        
        // ì…ë ¥ì°½ ì¬ìƒì„±
        [1, 2, 3, 4].forEach(mId => {
            const area = document.getElementById(`m${mId}-input-area`);
            const monitor = document.getElementById(`m${mId}`);
            area.innerHTML = '';
            monitor.classList.remove('input-active');

            if (gameState.activeInputs[0] === mId) {
                createInput(area, 'p1');
                monitor.classList.add('input-active');
            } else if (gameState.activeInputs[1] === mId) {
                createInput(area, 'p2');
                monitor.classList.add('input-active');
            }
        });
        gameState.swapTime = 10;
    }

    function createInput(parent, player) {
        const input = document.createElement('input');
        input.placeholder = `${player.toUpperCase()} ì…ë ¥ì°½!`;
        input.addEventListener('keypress', (e) => {
            if(e.key === 'Enter') {
                processCommand(player, e.target.value);
                e.target.value = '';
            }
        });
        parent.appendChild(input);
        input.focus();
    }

    // 3. í•µì‹¬ ê²Œì„ ë¡œì§ (íƒ€ì íŒ ë’¤ì§‘ê¸° ë° ë°œì „)
    function processCommand(player, val) {
        // ë‹¨ì–´ ì ë ¹ ë¡œì§
        const target = gameState.map.find(c => c.word === val);
        if (target) {
            // ì˜êµ¬ ë•…ì¸ ê²½ìš° ë°œì „/ê³µê²©
            if (target.fixedOwner === player) {
                upgradeLand(target);
            } else if (target.fixedOwner && target.fixedOwner !== player) {
                attackLand(player, target);
            } else {
                // ì¼ë°˜ ë•… ì„ì‹œ ì ë ¹
                target.owner = player;
            }
        }
        renderMap();
    }

    function upgradeLand(land) {
        if (land.level < 4) land.level++;
    }

    function attackLand(attacker, target) {
        // ì¸ì ‘ ì²´í¬ (ìƒí•˜ì¢Œìš°) ë° ìƒì„± ì²´í¬
        // ê°„ë‹¨í•œ ì˜ˆì‹œë¡œ ìƒì„±: ë„ì‹œ(2)ëŠ” ë§ˆì„(1)ì„ ì¸ì ‘ ì‹œ íŒŒê´´
        const attackerLands = gameState.map.filter(l => l.fixedOwner === attacker);
        const isAdjacent = attackerLands.some(l => 
            Math.abs(l.id - target.id) === 1 || Math.abs(l.id - target.id) === 4
        );

        if (isAdjacent) {
            const myMaxLevel = Math.max(...attackerLands.map(l => l.level));
            if (myMaxLevel > target.level) {
                target.level = 0; // ë¬´ë„ˆëœ¨ë¦¼
                target.fixedOwner = null; // ì˜êµ¬ê¶Œ ë°•íƒˆ (í˜¹ì€ ë ˆë²¨ë§Œ ì´ˆê¸°í™”)
            }
        }
    }

    // 4. ì‹œê°„ íë¦„ ë° ë¼ìš´ë“œ ì¢…ë£Œ
    function tick() {
        // ìœ„ì¹˜ ë³€ê²½ íƒ€ì´ë¨¸
        gameState.swapTime--;
        document.getElementById('swap-timer').style.width = (gameState.swapTime / 10) * 100 + "%";
        if (gameState.swapTime <= 0) shuffleInputPositions();

        // ë¼ìš´ë“œ íƒ€ì´ë¨¸
        gameState.roundTime--;
        document.getElementById('round-info').innerText = `ë¼ìš´ë“œ ${gameState.round}/16 (ë‚¨ì€ ì‹œê°„: ${gameState.roundTime}s)`;
        
        if (gameState.roundTime <= 0) {
            endRound();
        }
    }

    function endRound() {
        // 1. ì´ë²ˆ ë¼ìš´ë“œ ìŠ¹ì ê³„ì‚°
        const p1Count = gameState.map.filter(c => c.owner === 'p1').length;
        const p2Count = gameState.map.filter(c => c.owner === 'p2').length;
        const winner = p1Count > p2Count ? 'p1' : 'p2';

        // 2. ìŠ¹ë¦¬íŒ€ì´ ì˜êµ¬ ë•… ì„ íƒ (ì—¬ê¸°ì„œëŠ” ëœë¤ ì„ íƒì´ë‚˜ UI í´ë¦­ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥)
        const available = gameState.map.filter(c => !c.fixedOwner && c.owner === winner);
        if (available.length > 0) {
            available[0].fixedOwner = winner;
            available[0].level = 1; // ë§ˆì„ ìƒì„±
        }

        // 3. ìì› íšë“ (ì˜êµ¬ ë•…ì—ì„œ)
        gameState.map.forEach(l => {
            if(l.fixedOwner) {
                gameState[l.fixedOwner].res[l.resType] += (l.level * 10);
            }
        });

        // 4. ë¦¬ì…‹
        gameState.round++;
        gameState.roundTime = 60;
        gameState.map.forEach(c => c.owner = null);
        if(gameState.round > 16) alert("ìµœì¢… ê²Œì„ ì¢…ë£Œ!");
        renderMap();
    }

    function renderMap() {
        const display = document.getElementById('map-display');
        display.innerHTML = '';
        gameState.map.forEach(c => {
            const el = document.createElement('div');
            el.className = 'cell';
            if (c.fixedOwner) el.classList.add(`${c.fixedOwner}-fixed`);
            else if (c.owner) el.classList.add(`${c.owner}-temp`);
            
            el.innerHTML = `
                <span class="level-tag">${LEVELS[c.level]}</span>
                <b>${c.word}</b>
                <span>${RES_TYPES[c.resType]}</span>
            `;
            display.appendChild(el);
        });
        document.getElementById('p1-res').innerText = gameState.p1.res.join('/');
        document.getElementById('p2-res').innerText = gameState.p2.res.join('/');
    }

    init();
</script>
</body>
</html>
